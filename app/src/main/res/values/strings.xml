<resources>
    <string name="app_name">ComputerArchitecture</string>
    <string name="multithreading">Multithreading</string>
    <string name="computer_architecture">Computer Architecture</string>
    <string name="static_scheduling_name">Static Scheduling</string>
    <string name="static_scheduling_description">The Compiler can attempt to schedule instructions. </string>
    <string name="dynamic_scheduling_name">Dynamic scheduling</string>
    <string name="dynamic_scheduling_description">The Hardware rearranges the instruction execution to reduce the stalls.</string>
    <string name="as_soon_as_possible_name">As soon as possible (ASAP)</string>
    <string name="as_soon_as_possible_description">Executes instructions as soon as possible.</string>
    <string name="as_late_as_possible_name">As late as possible(ALAP)</string>
    <string name="as_late_as_possible_description">Executes instructions as late as possible.</string>
    <string name="cgmt_description">Long stalls are partially\nhidden by switching to another thread that uses the resources of the processor.\nThis switching reduces the number of completely idle clock cycles. In a coarse-\ngrained multithreaded processor, however, thread switching only occurs when\nthere is a stall. Because the new thread has a start-up period, there are likely to be\nsome fully idle cycles remaining.</string>
    <string name="fgmt_description">The interleaving of threads can eliminate fully empty\nslots. In addition, because the issuing thread is changed on every clock cycle,\nlonger latency operations can be hidden. Because instruction issue and execution\nare connected, a thread can only issue as many instructions as are ready. With a\nnarrow issue width this is not a problem (a cycle is either occupied or not), which\nis why fine-grained multithreading works perfectly for a single issue processor,\nand SMT would make no sense</string>
    <string name="smt_description">If one implements fine-grained threading on top of a multiple-issue dynami-\ncally schedule processor, the result is SMT. In all existing SMT implementations,\nall issues come from one thread, although instructions from different threads can\ninitiate execution in the same cycle, using the dynamic scheduling hardware to\ndetermine what instructions are ready. Simultaneous multithreading uses the insight that a dynamically scheduled\nprocessor already has many of the hardware mechanisms needed to support the\nmechanism, including a large virtual register set</string>
</resources>